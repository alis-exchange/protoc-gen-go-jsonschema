// Code generated by protoc-gen-go-jsonschema. DO NOT EDIT.
//
// Source: users/v1/user.proto
//
// Generated on: 2026-01-15 11:48:56 UTC

package usersv1

import (
	"github.com/google/jsonschema-go/jsonschema"
)

// JsonSchema returns the JSON schema for the Address message.
func (x *Address) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = Address_JsonSchema_WithDefs(defs)
	root := defs["users.v1.Address"]
	delete(defs, "users.v1.Address")
	root.Definitions = defs
	return root
}

func Address_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.Address"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.Address"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "Address represents a physical mailing address.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"city",
			"zipCode",
			"country",
			"latitude",
			"longitude",
			"addressDetails",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.Address"] = schema

	schema.Properties["street"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The street address including house number and street name.",
	}

	schema.Properties["city"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The city name.",
	}

	schema.Properties["state"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The state or province name.",
	}

	schema.Properties["zipCode"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The postal or zip code.",
	}

	schema.Properties["country"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The country name or code.",
	}

	schema.Properties["latitude"] = &jsonschema.Schema{
		Type:        "number",
		Title:       "",
		Description: "The latitude coordinate of the address.",
	}

	schema.Properties["longitude"] = &jsonschema.Schema{
		Type:        "number",
		Title:       "",
		Description: "The longitude coordinate of the address.",
	}

	schema.Properties["addressDetails"] = Address_AddressDetails_JsonSchema_WithDefs(defs)

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.Address"}
}

// JsonSchema returns the JSON schema for the AddressDetails message.
func (x *Address_AddressDetails) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = Address_AddressDetails_JsonSchema_WithDefs(defs)
	root := defs["users.v1.Address.AddressDetails"]
	delete(defs, "users.v1.Address.AddressDetails")
	root.Definitions = defs
	return root
}

func Address_AddressDetails_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.Address.AddressDetails"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.Address.AddressDetails"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "AddressDetails contains additional structured address information.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"street",
			"city",
			"state",
			"zipCode",
			"country",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.Address.AddressDetails"] = schema

	schema.Properties["street"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The street name.",
	}

	schema.Properties["city"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The city name.",
	}

	schema.Properties["state"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The state or province.",
	}

	schema.Properties["zipCode"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The postal code.",
	}

	schema.Properties["country"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The country code.",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.Address.AddressDetails"}
}

// JsonSchema returns the JSON schema for the AddressDetails message.
func (x *AddressDetails) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = AddressDetails_JsonSchema_WithDefs(defs)
	root := defs["users.v1.AddressDetails"]
	delete(defs, "users.v1.AddressDetails")
	root.Definitions = defs
	return root
}

func AddressDetails_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.AddressDetails"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.AddressDetails"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "AddressDetails represents detailed address information.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"street",
			"city",
			"state",
			"zipCode",
			"country",
			"nestedAddressDetails",
			"repeatedAddressDetails",
			"mapAddressDetails",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.AddressDetails"] = schema

	schema.Properties["street"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The street name.",
	}

	schema.Properties["city"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The city name.",
	}

	schema.Properties["state"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The state or province.",
	}

	schema.Properties["zipCode"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The postal code.",
	}

	schema.Properties["country"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The country code.",
	}

	schema.Properties["nestedAddressDetails"] = AddressDetails_JsonSchema_WithDefs(defs)

	schema.Properties["repeatedAddressDetails"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Repeated address details.",
		Items:       AddressDetails_JsonSchema_WithDefs(defs),
	}

	schema.Properties["mapAddressDetails"] = &jsonschema.Schema{
		Type:                 "object",
		Title:                "",
		Description:          "Map of address details.",
		AdditionalProperties: AddressDetails_JsonSchema_WithDefs(defs),
	}

	schema.Properties["oneofAddressDetails"] = AddressDetails_JsonSchema_WithDefs(defs)

	schema.Properties["optionalAddressDetails"] = AddressDetails_JsonSchema_WithDefs(defs)

	schema.OneOf = []*jsonschema.Schema{
		{Required: []string{"oneofAddressDetails"}},
	}
	return &jsonschema.Schema{Ref: "#/$defs/users.v1.AddressDetails"}
}

// JsonSchema returns the JSON schema for the ContactInfo message.
func (x *ContactInfo) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = ContactInfo_JsonSchema_WithDefs(defs)
	root := defs["users.v1.ContactInfo"]
	delete(defs, "users.v1.ContactInfo")
	root.Definitions = defs
	return root
}

func ContactInfo_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.ContactInfo"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.ContactInfo"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "ContactInfo contains contact information for a user.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"phone",
			"mobile",
			"fax",
			"emails",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.ContactInfo"] = schema

	schema.Properties["phone"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "Primary Email",
		Description: "Primary phone number in E.164 format.",
		Format:      "email",
	}

	schema.Properties["mobile"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Mobile phone number in E.164 format.",
	}

	schema.Properties["fax"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Fax number if available.",
	}

	schema.Properties["emails"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of email addresses associated with the contact.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.ContactInfo"}
}

// JsonSchema returns the JSON schema for the Metadata message.
func (x *Metadata) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = Metadata_JsonSchema_WithDefs(defs)
	root := defs["users.v1.Metadata"]
	delete(defs, "users.v1.Metadata")
	root.Definitions = defs
	return root
}

func Metadata_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.Metadata"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.Metadata"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "Metadata contains additional key-value metadata for resources.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"tags",
			"numericTags",
			"extraData",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.Metadata"] = schema

	schema.Properties["tags"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string tags for categorization.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["numericTags"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of numeric tags with string values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["extraData"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Additional unstructured data stored as a protobuf Struct.",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.Metadata"}
}

// JsonSchema returns the JSON schema for the ComprehensiveUser message.
func (x *ComprehensiveUser) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = ComprehensiveUser_JsonSchema_WithDefs(defs)
	root := defs["users.v1.ComprehensiveUser"]
	delete(defs, "users.v1.ComprehensiveUser")
	root.Definitions = defs
	return root
}

func ComprehensiveUser_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.ComprehensiveUser"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.ComprehensiveUser"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "ComprehensiveUser is a comprehensive user message demonstrating all proto3\n features.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"id",
			"name",
			"isActive",
			"age",
			"userId",
			"score",
			"accountNumber",
			"signedScore",
			"signedId",
			"fixedUint",
			"fixedUlong",
			"sfixedInt",
			"sfixedLong",
			"rating",
			"balance",
			"avatar",
			"signature",
			"status",
			"accountType",
			"address",
			"contact",
			"metadata",
			"tags",
			"scores",
			"flags",
			"ratings",
			"balances",
			"images",
			"statusHistory",
			"priorities",
			"addresses",
			"contacts",
			"attributes",
			"numericAttributes",
			"stringToInt",
			"stringToBool",
			"addressMap",
			"statusMap",
			"addressDetailsMap",
			"createdAt",
			"updatedAt",
			"sessionDuration",
			"extraData",
			"dynamicData",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.ComprehensiveUser"] = schema

	schema.Properties["id"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Unique identifier for the user.",
	}

	schema.Properties["name"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Full name of the user.",
	}

	schema.Properties["isActive"] = &jsonschema.Schema{
		Type:        "boolean",
		Title:       "",
		Description: "Whether the user account is currently active.",
	}

	schema.Properties["age"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Age of the user in years.",
	}

	schema.Properties["userId"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Unique user ID as a 64-bit integer.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["score"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "User score as an unsigned 32-bit integer.",
	}

	schema.Properties["accountNumber"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Account number as an unsigned 64-bit integer.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["signedScore"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Signed score using zigzag encoding.",
	}

	schema.Properties["signedId"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Signed ID using zigzag encoding.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["fixedUint"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Fixed-width unsigned 32-bit integer.",
	}

	schema.Properties["fixedUlong"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Fixed-width unsigned 64-bit integer.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["sfixedInt"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Fixed-width signed 32-bit integer.",
	}

	schema.Properties["sfixedLong"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Fixed-width signed 64-bit integer.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["rating"] = &jsonschema.Schema{
		Type:        "number",
		Title:       "",
		Description: "User rating as a single-precision float.",
	}

	schema.Properties["balance"] = &jsonschema.Schema{
		Type:        "number",
		Title:       "",
		Description: "Account balance as a double-precision float.",
	}

	schema.Properties["avatar"] = &jsonschema.Schema{
		Type:            "string",
		Title:           "",
		Description:     "User avatar image as raw bytes.",
		ContentEncoding: "base64",
	}

	schema.Properties["signature"] = &jsonschema.Schema{
		Type:            "string",
		Title:           "",
		Description:     "Digital signature as raw bytes.",
		ContentEncoding: "base64",
	}

	schema.Properties["status"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Current status of the user account.",
		Enum: []any{
			"USER_STATUS_UNSPECIFIED",
			"USER_STATUS_ACTIVE",
			"USER_STATUS_INACTIVE",
			"USER_STATUS_SUSPENDED",
			"USER_STATUS_DELETED",
		},
	}

	schema.Properties["accountType"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Type of account subscription.",
		Enum: []any{
			"ACCOUNT_TYPE_UNSPECIFIED",
			"ACCOUNT_TYPE_FREE",
			"ACCOUNT_TYPE_PREMIUM",
			"ACCOUNT_TYPE_ENTERPRISE",
		},
	}

	schema.Properties["address"] = Address_JsonSchema_WithDefs(defs)

	schema.Properties["contact"] = ContactInfo_JsonSchema_WithDefs(defs)

	schema.Properties["metadata"] = Metadata_JsonSchema_WithDefs(defs)

	schema.Properties["tags"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of tags associated with the user.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["scores"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Historical scores for the user.",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["flags"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Boolean flags for various user settings.",
		Items: &jsonschema.Schema{
			Type: "boolean",
		},
	}

	schema.Properties["ratings"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Historical ratings for the user.",
		Items: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["balances"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Historical balance snapshots.",
		Items: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["images"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Additional image data.",
		Items: &jsonschema.Schema{
			Type:            "string",
			ContentEncoding: "base64",
		},
	}

	schema.Properties["statusHistory"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "History of user status changes.",
		Items: &jsonschema.Schema{
			Type: "string",
			Enum: []any{
				"USER_STATUS_UNSPECIFIED",
				"USER_STATUS_ACTIVE",
				"USER_STATUS_INACTIVE",
				"USER_STATUS_SUSPENDED",
				"USER_STATUS_DELETED",
			},
		},
	}

	schema.Properties["priorities"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of priority levels assigned to the user.",
		Items: &jsonschema.Schema{
			Type: "string",
			Enum: []any{
				"PRIORITY_UNSPECIFIED",
				"PRIORITY_LOW",
				"PRIORITY_MEDIUM",
				"PRIORITY_HIGH",
				"PRIORITY_URGENT",
			},
		},
	}

	schema.Properties["addresses"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of all addresses associated with the user.",
		Items:       Address_JsonSchema_WithDefs(defs),
	}

	schema.Properties["contacts"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of contact information entries.",
		Items:       ContactInfo_JsonSchema_WithDefs(defs),
	}

	schema.Properties["attributes"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string attributes with string values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["numericAttributes"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of numeric attributes with string values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["stringToInt"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string keys to integer values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["stringToBool"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string keys to boolean values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "boolean",
		},
	}

	schema.Properties["addressMap"] = &jsonschema.Schema{
		Type:                 "object",
		Title:                "",
		Description:          "Map of string keys to Address message values.",
		AdditionalProperties: Address_JsonSchema_WithDefs(defs),
	}

	schema.Properties["statusMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string keys to UserStatus enum values.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
			Enum: []any{
				"USER_STATUS_UNSPECIFIED",
				"USER_STATUS_ACTIVE",
				"USER_STATUS_INACTIVE",
				"USER_STATUS_SUSPENDED",
				"USER_STATUS_DELETED",
			},
		},
	}

	schema.Properties["addressDetailsMap"] = &jsonschema.Schema{
		Type:                 "object",
		Title:                "",
		Description:          "Map of string keys to Address.AddressDetails message values.",
		AdditionalProperties: Address_AddressDetails_JsonSchema_WithDefs(defs),
	}

	schema.Properties["email"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Email address as identifier.",
	}

	schema.Properties["username"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Username as identifier.",
	}

	schema.Properties["userNumber"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "User number as identifier.",
		Pattern:     "^-?[0-9]+$",
	}

	schema.Properties["creditCard"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Credit card number.",
	}

	schema.Properties["bankAccount"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Bank account number.",
	}

	schema.Properties["cryptoWallet"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Cryptocurrency wallet address.",
	}

	schema.Properties["contactInfo"] = ContactInfo_JsonSchema_WithDefs(defs)

	schema.Properties["mailingAddress"] = Address_JsonSchema_WithDefs(defs)

	schema.Properties["createdAt"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp when the user account was created.",
		Format:      "date-time",
	}

	schema.Properties["updatedAt"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp when the user account was last updated.",
		Format:      "date-time",
	}

	schema.Properties["sessionDuration"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Duration of the current user session.",
		Pattern:     "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
	}

	schema.Properties["extraData"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Additional data stored as Any type.",
	}

	schema.Properties["dynamicData"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Dynamic data stored as Struct type.",
	}

	schema.Properties["nickname"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Optional nickname for the user.",
	}

	schema.Properties["optionalAge"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Optional age if not provided in the main age field.",
	}

	schema.Properties["optionalFlag"] = &jsonschema.Schema{
		Type:        "boolean",
		Title:       "",
		Description: "Optional boolean flag.",
	}

	schema.Properties["optionalStatus"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Optional status override.",
		Enum: []any{
			"USER_STATUS_UNSPECIFIED",
			"USER_STATUS_ACTIVE",
			"USER_STATUS_INACTIVE",
			"USER_STATUS_SUSPENDED",
			"USER_STATUS_DELETED",
		},
	}

	schema.Properties["optionalAddress"] = Address_JsonSchema_WithDefs(defs)

	schema.AllOf = []*jsonschema.Schema{
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"contactInfo"}},
				{Required: []string{"mailingAddress"}},
			},
		},
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"email"}},
				{Required: []string{"username"}},
				{Required: []string{"userNumber"}},
			},
		},
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"creditCard"}},
				{Required: []string{"bankAccount"}},
				{Required: []string{"cryptoWallet"}},
			},
		},
	}
	return &jsonschema.Schema{Ref: "#/$defs/users.v1.ComprehensiveUser"}
}

// JsonSchema returns the JSON schema for the User message.
func (x *User) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = User_JsonSchema_WithDefs(defs)
	root := defs["users.v1.User"]
	delete(defs, "users.v1.User")
	root.Definitions = defs
	return root
}

func User_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.User"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.User"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "User represents a basic user account.\n This is kept for backward compatibility with existing clients.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"id",
			"name",
			"email",
			"password",
			"status",
			"address",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.User"] = schema

	schema.Properties["id"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Unique identifier for the user.",
	}

	schema.Properties["name"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Full name of the user.",
	}

	schema.Properties["email"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Email address of the user.",
	}

	schema.Properties["password"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Hashed password (never store plain text passwords).",
	}

	schema.Properties["status"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Current status of the user account.",
		Enum: []any{
			"USER_STATUS_UNSPECIFIED",
			"USER_STATUS_ACTIVE",
			"USER_STATUS_INACTIVE",
			"USER_STATUS_SUSPENDED",
			"USER_STATUS_DELETED",
		},
	}

	schema.Properties["address"] = Address_JsonSchema_WithDefs(defs)

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.User"}
}

// JsonSchema returns the JSON schema for the CreateUserRequest message.
func (x *CreateUserRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = CreateUserRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.CreateUserRequest"]
	delete(defs, "users.v1.CreateUserRequest")
	root.Definitions = defs
	return root
}

func CreateUserRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.CreateUserRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.CreateUserRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "CreateUserRequest contains information needed to create a new user.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"name",
			"email",
			"password",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.CreateUserRequest"] = schema

	schema.Properties["name"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Full name of the user to create.",
	}

	schema.Properties["email"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Email address for the new user account.",
	}

	schema.Properties["password"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Password for the new user account (will be hashed).",
	}

	schema.Properties["address"] = Address_JsonSchema_WithDefs(defs)

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.CreateUserRequest"}
}

// JsonSchema returns the JSON schema for the GetUserRequest message.
func (x *GetUserRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = GetUserRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.GetUserRequest"]
	delete(defs, "users.v1.GetUserRequest")
	root.Definitions = defs
	return root
}

func GetUserRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.GetUserRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.GetUserRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "GetUserRequest contains the user ID to retrieve.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"id",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.GetUserRequest"] = schema

	schema.Properties["id"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The unique identifier of the user to retrieve.",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.GetUserRequest"}
}

// JsonSchema returns the JSON schema for the UpdateUserRequest message.
func (x *UpdateUserRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = UpdateUserRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.UpdateUserRequest"]
	delete(defs, "users.v1.UpdateUserRequest")
	root.Definitions = defs
	return root
}

func UpdateUserRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.UpdateUserRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.UpdateUserRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "UpdateUserRequest contains the updated user information.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"user",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.UpdateUserRequest"] = schema

	schema.Properties["user"] = User_JsonSchema_WithDefs(defs)

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.UpdateUserRequest"}
}

// JsonSchema returns the JSON schema for the DeleteUserRequest message.
func (x *DeleteUserRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = DeleteUserRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.DeleteUserRequest"]
	delete(defs, "users.v1.DeleteUserRequest")
	root.Definitions = defs
	return root
}

func DeleteUserRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.DeleteUserRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.DeleteUserRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "DeleteUserRequest contains the user ID to delete.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"id",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.DeleteUserRequest"] = schema

	schema.Properties["id"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "The unique identifier of the user to delete.",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.DeleteUserRequest"}
}

// JsonSchema returns the JSON schema for the DeleteUserResponse message.
func (x *DeleteUserResponse) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = DeleteUserResponse_JsonSchema_WithDefs(defs)
	root := defs["users.v1.DeleteUserResponse"]
	delete(defs, "users.v1.DeleteUserResponse")
	root.Definitions = defs
	return root
}

func DeleteUserResponse_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.DeleteUserResponse"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.DeleteUserResponse"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "DeleteUserResponse indicates whether the deletion was successful.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"success",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.DeleteUserResponse"] = schema

	schema.Properties["success"] = &jsonschema.Schema{
		Type:        "boolean",
		Title:       "",
		Description: "True if the user was successfully deleted, false otherwise.",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.DeleteUserResponse"}
}

// JsonSchema returns the JSON schema for the CreateComprehensiveUserRequest message.
func (x *CreateComprehensiveUserRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = CreateComprehensiveUserRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.CreateComprehensiveUserRequest"]
	delete(defs, "users.v1.CreateComprehensiveUserRequest")
	root.Definitions = defs
	return root
}

func CreateComprehensiveUserRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.CreateComprehensiveUserRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.CreateComprehensiveUserRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "CreateComprehensiveUserRequest contains all information needed to create a\n comprehensive user.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"user",
			"metadata",
			"tags",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.CreateComprehensiveUserRequest"] = schema

	schema.Properties["user"] = ComprehensiveUser_JsonSchema_WithDefs(defs)

	schema.Properties["metadata"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Additional metadata to associate with the user.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["tags"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "Tags to categorize the user.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.CreateComprehensiveUserRequest"}
}

// JsonSchema returns the JSON schema for the BatchGetUsersRequest message.
func (x *BatchGetUsersRequest) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = BatchGetUsersRequest_JsonSchema_WithDefs(defs)
	root := defs["users.v1.BatchGetUsersRequest"]
	delete(defs, "users.v1.BatchGetUsersRequest")
	root.Definitions = defs
	return root
}

func BatchGetUsersRequest_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.BatchGetUsersRequest"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.BatchGetUsersRequest"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "BatchGetUsersRequest contains criteria for retrieving multiple users.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"ids",
			"userNumbers",
			"filters",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.BatchGetUsersRequest"] = schema

	schema.Properties["ids"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of user IDs to retrieve.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["userNumbers"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of user numbers to retrieve.",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["filters"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of filter criteria (e.g., {\"status\": \"active\"}).",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["emailQuery"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Query users by email address.",
	}

	schema.Properties["nameQuery"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Query users by name (partial match).",
	}

	schema.Properties["statusFilter"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Filter users by status.",
		Enum: []any{
			"USER_STATUS_UNSPECIFIED",
			"USER_STATUS_ACTIVE",
			"USER_STATUS_INACTIVE",
			"USER_STATUS_SUSPENDED",
			"USER_STATUS_DELETED",
		},
	}

	schema.OneOf = []*jsonschema.Schema{
		{Required: []string{"emailQuery"}},
		{Required: []string{"nameQuery"}},
		{Required: []string{"statusFilter"}},
	}
	return &jsonschema.Schema{Ref: "#/$defs/users.v1.BatchGetUsersRequest"}
}

// JsonSchema returns the JSON schema for the BatchGetUsersResponse message.
func (x *BatchGetUsersResponse) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = BatchGetUsersResponse_JsonSchema_WithDefs(defs)
	root := defs["users.v1.BatchGetUsersResponse"]
	delete(defs, "users.v1.BatchGetUsersResponse")
	root.Definitions = defs
	return root
}

func BatchGetUsersResponse_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.BatchGetUsersResponse"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.BatchGetUsersResponse"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "BatchGetUsersResponse contains the results of a batch user retrieval.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"users",
			"totalCount",
			"hasMore",
			"queryTimestamp",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.BatchGetUsersResponse"] = schema

	schema.Properties["users"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of retrieved users.",
		Items:       ComprehensiveUser_JsonSchema_WithDefs(defs),
	}

	schema.Properties["totalCount"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Total count of users matching the query.",
	}

	schema.Properties["hasMore"] = &jsonschema.Schema{
		Type:        "boolean",
		Title:       "",
		Description: "Whether there are more users available (for pagination).",
	}

	schema.Properties["queryTimestamp"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp when the query was executed.",
		Format:      "date-time",
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.BatchGetUsersResponse"}
}

// JsonSchema returns the JSON schema for the UserProfile message.
func (x *UserProfile) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = UserProfile_JsonSchema_WithDefs(defs)
	root := defs["users.v1.UserProfile"]
	delete(defs, "users.v1.UserProfile")
	root.Definitions = defs
	return root
}

func UserProfile_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.UserProfile"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.UserProfile"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "UserProfile contains a user profile with additional profile-specific\n information.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"user",
			"shippingAddresses",
			"contactMethods",
			"customData",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.UserProfile"] = schema

	schema.Properties["user"] = ComprehensiveUser_JsonSchema_WithDefs(defs)

	schema.Properties["shippingAddresses"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of shipping addresses for the user.",
		Items:       Address_JsonSchema_WithDefs(defs),
	}

	schema.Properties["contactMethods"] = &jsonschema.Schema{
		Type:                 "object",
		Title:                "",
		Description:          "Map of contact methods keyed by method type.",
		AdditionalProperties: ContactInfo_JsonSchema_WithDefs(defs),
	}

	schema.Properties["personal"] = PersonalProfile_JsonSchema_WithDefs(defs)

	schema.Properties["business"] = BusinessProfile_JsonSchema_WithDefs(defs)

	schema.Properties["customData"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Additional custom data stored as Any type.",
	}

	schema.OneOf = []*jsonschema.Schema{
		{Required: []string{"personal"}},
		{Required: []string{"business"}},
	}
	return &jsonschema.Schema{Ref: "#/$defs/users.v1.UserProfile"}
}

// JsonSchema returns the JSON schema for the PersonalProfile message.
func (x *PersonalProfile) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = PersonalProfile_JsonSchema_WithDefs(defs)
	root := defs["users.v1.PersonalProfile"]
	delete(defs, "users.v1.PersonalProfile")
	root.Definitions = defs
	return root
}

func PersonalProfile_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.PersonalProfile"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.PersonalProfile"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "PersonalProfile contains information specific to personal user accounts.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"firstName",
			"lastName",
			"dateOfBirth",
			"interests",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.PersonalProfile"] = schema

	schema.Properties["firstName"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "First name of the user.",
	}

	schema.Properties["lastName"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Last name of the user.",
	}

	schema.Properties["dateOfBirth"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Date of birth of the user.",
		Format:      "date-time",
	}

	schema.Properties["interests"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of user interests or hobbies.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.PersonalProfile"}
}

// JsonSchema returns the JSON schema for the BusinessProfile message.
func (x *BusinessProfile) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = BusinessProfile_JsonSchema_WithDefs(defs)
	root := defs["users.v1.BusinessProfile"]
	delete(defs, "users.v1.BusinessProfile")
	root.Definitions = defs
	return root
}

func BusinessProfile_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.BusinessProfile"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.BusinessProfile"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "BusinessProfile contains information specific to business user accounts.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"companyName",
			"taxId",
			"businessAddress",
			"departments",
			"employeeCounts",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.BusinessProfile"] = schema

	schema.Properties["companyName"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Name of the company.",
	}

	schema.Properties["taxId"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Tax identification number for the business.",
	}

	schema.Properties["businessAddress"] = Address_JsonSchema_WithDefs(defs)

	schema.Properties["departments"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of department names in the company.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["employeeCounts"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of department names to employee counts.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "integer",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.BusinessProfile"}
}

// JsonSchema returns the JSON schema for the RepeatedFieldsDemo message.
func (x *RepeatedFieldsDemo) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = RepeatedFieldsDemo_JsonSchema_WithDefs(defs)
	root := defs["users.v1.RepeatedFieldsDemo"]
	delete(defs, "users.v1.RepeatedFieldsDemo")
	root.Definitions = defs
	return root
}

func RepeatedFieldsDemo_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.RepeatedFieldsDemo"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.RepeatedFieldsDemo"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "RepeatedFieldsDemo demonstrates all repeated field types.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"stringList",
			"intList",
			"longList",
			"uintList",
			"ulongList",
			"sintList",
			"slongList",
			"fixedUintList",
			"fixedUlongList",
			"sfixedIntList",
			"sfixedLongList",
			"floatList",
			"doubleList",
			"boolList",
			"bytesList",
			"enumList",
			"messageList",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.RepeatedFieldsDemo"] = schema

	schema.Properties["stringList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of strings.",
		Items: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["intList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of 32-bit integers.",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["longList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of 64-bit integers.",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["uintList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of unsigned 32-bit integers.",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["ulongList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of unsigned 64-bit integers.",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["sintList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of signed 32-bit integers (zigzag encoded).",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["slongList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of signed 64-bit integers (zigzag encoded).",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["fixedUintList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of fixed-width unsigned 32-bit integers.",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["fixedUlongList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of fixed-width unsigned 64-bit integers.",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["sfixedIntList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of fixed-width signed 32-bit integers.",
		Items: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["sfixedLongList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of fixed-width signed 64-bit integers.",
		Items: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["floatList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of single-precision floats.",
		Items: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["doubleList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of double-precision floats.",
		Items: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["boolList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of boolean values.",
		Items: &jsonschema.Schema{
			Type: "boolean",
		},
	}

	schema.Properties["bytesList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of byte arrays.",
		Items: &jsonschema.Schema{
			Type:            "string",
			ContentEncoding: "base64",
		},
	}

	schema.Properties["enumList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of UserStatus enum values.",
		Items: &jsonschema.Schema{
			Type: "string",
			Enum: []any{
				"USER_STATUS_UNSPECIFIED",
				"USER_STATUS_ACTIVE",
				"USER_STATUS_INACTIVE",
				"USER_STATUS_SUSPENDED",
				"USER_STATUS_DELETED",
			},
		},
	}

	schema.Properties["messageList"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of Address messages.",
		Items:       Address_JsonSchema_WithDefs(defs),
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.RepeatedFieldsDemo"}
}

// JsonSchema returns the JSON schema for the MapFieldsDemo message.
func (x *MapFieldsDemo) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = MapFieldsDemo_JsonSchema_WithDefs(defs)
	root := defs["users.v1.MapFieldsDemo"]
	delete(defs, "users.v1.MapFieldsDemo")
	root.Definitions = defs
	return root
}

func MapFieldsDemo_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.MapFieldsDemo"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.MapFieldsDemo"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "MapFieldsDemo demonstrates all map field types.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"stringMap",
			"stringIntMap",
			"stringLongMap",
			"stringBoolMap",
			"stringFloatMap",
			"stringDoubleMap",
			"stringBytesMap",
			"stringEnumMap",
			"stringMessageMap",
			"intStringMap",
			"longStringMap",
			"uintStringMap",
			"boolStringMap",
			"intIntMap",
			"stringTimestampMap",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.MapFieldsDemo"] = schema

	schema.Properties["stringMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to string.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
	}

	schema.Properties["stringIntMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to 32-bit integer.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "integer",
		},
	}

	schema.Properties["stringLongMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to 64-bit integer.",
		AdditionalProperties: &jsonschema.Schema{
			Type:    "string",
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["stringBoolMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to boolean.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "boolean",
		},
	}

	schema.Properties["stringFloatMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to single-precision float.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["stringDoubleMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to double-precision float.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "number",
		},
	}

	schema.Properties["stringBytesMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to byte array.",
		AdditionalProperties: &jsonschema.Schema{
			Type:            "string",
			ContentEncoding: "base64",
		},
	}

	schema.Properties["stringEnumMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to UserStatus enum.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
			Enum: []any{
				"USER_STATUS_UNSPECIFIED",
				"USER_STATUS_ACTIVE",
				"USER_STATUS_INACTIVE",
				"USER_STATUS_SUSPENDED",
				"USER_STATUS_DELETED",
			},
		},
	}

	schema.Properties["stringMessageMap"] = &jsonschema.Schema{
		Type:                 "object",
		Title:                "",
		Description:          "Map of string to Address message.",
		AdditionalProperties: Address_JsonSchema_WithDefs(defs),
	}

	schema.Properties["intStringMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of 32-bit integer to string.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["longStringMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of 64-bit integer to string.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["uintStringMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of unsigned 32-bit integer to string.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["boolStringMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of boolean to string.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "string",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^(true|false)$",
		},
	}

	schema.Properties["intIntMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of 32-bit integer to 32-bit integer.",
		AdditionalProperties: &jsonschema.Schema{
			Type: "integer",
		},
		PropertyNames: &jsonschema.Schema{
			Pattern: "^-?[0-9]+$",
		},
	}

	schema.Properties["stringTimestampMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string to Timestamp.",
		AdditionalProperties: &jsonschema.Schema{
			Type:   "string",
			Format: "date-time",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.MapFieldsDemo"}
}

// JsonSchema returns the JSON schema for the OneOfDemo message.
func (x *OneOfDemo) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = OneOfDemo_JsonSchema_WithDefs(defs)
	root := defs["users.v1.OneOfDemo"]
	delete(defs, "users.v1.OneOfDemo")
	root.Definitions = defs
	return root
}

func OneOfDemo_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.OneOfDemo"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.OneOfDemo"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "OneOfDemo demonstrates multiple oneof field groups.",
		Properties:  make(map[string]*jsonschema.Schema),
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.OneOfDemo"] = schema

	schema.Properties["stringValue"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "String value option.",
	}

	schema.Properties["intValue"] = &jsonschema.Schema{
		Type:        "integer",
		Title:       "",
		Description: "Integer value option.",
	}

	schema.Properties["boolValue"] = &jsonschema.Schema{
		Type:        "boolean",
		Title:       "",
		Description: "Boolean value option.",
	}

	schema.Properties["address"] = Address_JsonSchema_WithDefs(defs)

	schema.Properties["contact"] = ContactInfo_JsonSchema_WithDefs(defs)

	schema.Properties["metadata"] = Metadata_JsonSchema_WithDefs(defs)

	schema.Properties["status"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "UserStatus enum option.",
		Enum: []any{
			"USER_STATUS_UNSPECIFIED",
			"USER_STATUS_ACTIVE",
			"USER_STATUS_INACTIVE",
			"USER_STATUS_SUSPENDED",
			"USER_STATUS_DELETED",
		},
	}

	schema.Properties["account"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "AccountType enum option.",
		Enum: []any{
			"ACCOUNT_TYPE_UNSPECIFIED",
			"ACCOUNT_TYPE_FREE",
			"ACCOUNT_TYPE_PREMIUM",
			"ACCOUNT_TYPE_ENTERPRISE",
		},
	}

	schema.Properties["priority"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Priority enum option.",
		Enum: []any{
			"PRIORITY_UNSPECIFIED",
			"PRIORITY_LOW",
			"PRIORITY_MEDIUM",
			"PRIORITY_HIGH",
			"PRIORITY_URGENT",
		},
	}

	schema.Properties["timestamp"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp value option.",
		Format:      "date-time",
	}

	schema.Properties["duration"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Duration value option.",
		Pattern:     "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
	}

	schema.Properties["anyData"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Any type value option.",
	}

	schema.AllOf = []*jsonschema.Schema{
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"stringValue"}},
				{Required: []string{"intValue"}},
				{Required: []string{"boolValue"}},
			},
		},
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"address"}},
				{Required: []string{"contact"}},
				{Required: []string{"metadata"}},
			},
		},
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"status"}},
				{Required: []string{"account"}},
				{Required: []string{"priority"}},
			},
		},
		{
			OneOf: []*jsonschema.Schema{
				{Required: []string{"timestamp"}},
				{Required: []string{"duration"}},
				{Required: []string{"anyData"}},
			},
		},
	}
	return &jsonschema.Schema{Ref: "#/$defs/users.v1.OneOfDemo"}
}

// JsonSchema returns the JSON schema for the WellKnownTypesDemo message.
func (x *WellKnownTypesDemo) JsonSchema() *jsonschema.Schema {
	defs := make(map[string]*jsonschema.Schema)
	_ = WellKnownTypesDemo_JsonSchema_WithDefs(defs)
	root := defs["users.v1.WellKnownTypesDemo"]
	delete(defs, "users.v1.WellKnownTypesDemo")
	root.Definitions = defs
	return root
}

func WellKnownTypesDemo_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {
	if _, ok := defs["users.v1.WellKnownTypesDemo"]; ok {
		return &jsonschema.Schema{Ref: "#/$defs/users.v1.WellKnownTypesDemo"}
	}

	schema := &jsonschema.Schema{
		Type:        "object",
		Description: "WellKnownTypesDemo demonstrates usage of well-known protobuf types.",
		Properties:  make(map[string]*jsonschema.Schema),
		Required: []string{
			"createdAt",
			"updatedAt",
			"timeDuration",
			"anyField",
			"structField",
			"valueField",
			"timestamps",
			"timestampMap",
		},
	}

	// Register schema BEFORE processing fields to handle self-references.
	// This prevents infinite recursion when a message contains itself.
	defs["users.v1.WellKnownTypesDemo"] = schema

	schema.Properties["createdAt"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp representing creation time.",
		Format:      "date-time",
	}

	schema.Properties["updatedAt"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Timestamp representing last update time.",
		Format:      "date-time",
	}

	schema.Properties["timeDuration"] = &jsonschema.Schema{
		Type:        "string",
		Title:       "",
		Description: "Duration representing a time span.",
		Pattern:     "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
	}

	schema.Properties["anyField"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Any type for storing arbitrary protobuf messages.",
	}

	schema.Properties["structField"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Struct type for storing arbitrary JSON-like data.",
	}

	schema.Properties["valueField"] = &jsonschema.Schema{
		Title:       "",
		Description: "Value type for storing a single JSON value.",
	}

	schema.Properties["timestamps"] = &jsonschema.Schema{
		Type:        "array",
		Title:       "",
		Description: "List of timestamps.",
		Items: &jsonschema.Schema{
			Type:   "string",
			Format: "date-time",
		},
	}

	schema.Properties["timestampMap"] = &jsonschema.Schema{
		Type:        "object",
		Title:       "",
		Description: "Map of string keys to Timestamp values.",
		AdditionalProperties: &jsonschema.Schema{
			Type:   "string",
			Format: "date-time",
		},
	}

	return &jsonschema.Schema{Ref: "#/$defs/users.v1.WellKnownTypesDemo"}
}
