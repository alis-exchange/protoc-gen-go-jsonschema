package plugin

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// An enumeration of the JSON Schema type names.
const (
	jsArray   = "array"
	jsBoolean = "boolean"
	jsInteger = "integer"
	jsNull    = "null"
	jsNumber  = "number"
	jsObject  = "object"
	jsString  = "string"
)

type Generator struct{}

func (gr *Generator) generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + "_jsonschema.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-jsonschema. DO NOT EDIT.")
	g.P("// ")
	g.P(fmt.Sprintf("// Source: %s", file.Desc.Path()))
	g.P("// ")
	g.P(fmt.Sprintf("// Generated on: %s UTC", time.Now().UTC().Format("2006-01-02 15:04:05")))

	g.P()
	g.P(fmt.Sprintf("package %s", file.GoPackageName))

	if len(file.Messages) > 0 {
		g.P("import (")
		g.P("\"github.com/google/jsonschema-go/jsonschema\"")
		g.P(")")
		g.P()
	}

	messages := gr.getMessages(file.Messages, make(map[string]bool))

	for _, msg := range messages {
		sg := &MessageSchemaGenerator{
			gr:      gr,
			gen:     g,
			visited: make(map[string]bool),
		}
		if err := sg.generateMessageJSONSchema(msg); err != nil {
			return nil, err
		}
		g.P()
	}

	return g, nil
}

func (gr *Generator) getMessages(messages []*protogen.Message, visited map[string]bool) []*protogen.Message {
	var results []*protogen.Message
	for _, message := range messages {
		messageName := string(message.Desc.FullName())
		if visited[messageName] {
			continue
		}
		visited[messageName] = true

		for _, field := range message.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind {
				nestedMessages := gr.getMessages([]*protogen.Message{field.Message}, visited)
				results = append(results, nestedMessages...)
			}
		}
		results = append(results, message)
	}
	return results
}

type MessageSchemaGenerator struct {
	gr      *Generator
	gen     *protogen.GeneratedFile
	visited map[string]bool
}

// schemaFieldConfig holds configuration for generating a JSON schema field.
type schemaFieldConfig struct {
	fieldName            string   // JSON field name
	title                string   // Schema title
	description          string   // Schema description
	typeName             string   // JSON Schema type ("array", "object", "string", etc.)
	format               string   // JSON Schema format ("date-time", "email", etc.)
	pattern              string   // Regex pattern for value validation
	propertyNamesPattern string   // Regex pattern for validating property names (map keys)
	enumValues           []string // Enum values (if any)
	isBytes              bool     // Whether this is a bytes field (adds ContentEncoding/Format)
	messageRef           string   // Message schema function reference (e.g., "Foo_JsonSchema()")
	nested               *schemaFieldConfig
}

func (sg *MessageSchemaGenerator) emitSchemaField(cfg schemaFieldConfig) {
	// Optimization: Direct function reference assignment
	if cfg.messageRef != "" && cfg.typeName == "" && cfg.nested == nil {
		sg.gen.P(fmt.Sprintf(`schema.Properties["%s"] = %s`, cfg.fieldName, cfg.messageRef))
		return
	}

	sg.gen.P(fmt.Sprintf(`schema.Properties["%s"] = &jsonschema.Schema{`, cfg.fieldName))
	if cfg.typeName != "" {
		sg.gen.P(fmt.Sprintf(`Type: "%s",`, cfg.typeName))
	}
	if cfg.format != "" {
		sg.gen.P(fmt.Sprintf(`Format: "%s",`, sg.gr.escapeGoString(cfg.format)))
	}
	if cfg.pattern != "" {
		sg.gen.P(fmt.Sprintf(`Pattern: "%s",`, sg.gr.escapeGoString(cfg.pattern)))
	}
	sg.gen.P(fmt.Sprintf(`Title: "%s",`, sg.gr.escapeGoString(cfg.title)))
	sg.gen.P(fmt.Sprintf(`Description: "%s",`, sg.gr.escapeGoString(cfg.description)))

	if cfg.propertyNamesPattern != "" {
		sg.gen.P(`PropertyNames: &jsonschema.Schema{`)
		sg.gen.P(fmt.Sprintf(`Pattern: "%s",`, sg.gr.escapeGoString(cfg.propertyNamesPattern)))
		sg.gen.P(`},`)
	}

	// Handle nested schemas (Arrays and Maps)
	if cfg.nested != nil {
		targetField := "Items" // Default for Array
		if cfg.typeName == jsObject {
			targetField = "AdditionalProperties"
		}

		if cfg.nested.messageRef != "" {
			sg.gen.P(fmt.Sprintf(`%s: %s,`, targetField, cfg.nested.messageRef))
		} else {
			sg.gen.P(fmt.Sprintf(`%s: &jsonschema.Schema{`, targetField))
			if cfg.nested.typeName != "" {
				sg.gen.P(fmt.Sprintf(`Type: "%s",`, cfg.nested.typeName))
			}
			if cfg.nested.pattern != "" {
				sg.gen.P(fmt.Sprintf(`Pattern: "%s",`, sg.gr.escapeGoString(cfg.nested.pattern)))
			}
			if cfg.nested.format != "" {
				sg.gen.P(fmt.Sprintf(`Format: "%s",`, sg.gr.escapeGoString(cfg.nested.format)))
			}
			sg.emitEnumAndBytesFields(cfg.nested)
			sg.gen.P(`},`)
		}
	}

	// Handle scalar enum and bytes at root level
	if cfg.typeName != jsArray && cfg.typeName != jsObject {
		sg.emitEnumAndBytesFields(&cfg)
		sg.gen.P(`Required: []string{},`)
	}

	sg.gen.P("}")
}

func (sg *MessageSchemaGenerator) emitEnumAndBytesFields(cfg *schemaFieldConfig) {
	if len(cfg.enumValues) > 0 {
		sg.gen.P(`Enum: []any{`)
		for _, enumValue := range cfg.enumValues {
			sg.gen.P(fmt.Sprintf(`"%s",`, enumValue))
		}
		sg.gen.P(`},`)
	}
	if cfg.isBytes {
		sg.gen.P(`ContentEncoding: "base64",`)
		// Format: byte is optional/OpenAPI specific, generally good to include
		// sg.gen.P(`Format: "byte",`)
	}
}

func (sg *MessageSchemaGenerator) emitArraySchema(field *protogen.Field, title, description string) error {
	kindTypeName, err := sg.getKindTypeName(field.Desc)
	if err != nil {
		return err
	}

	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsArray,
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		nestedCfg := sg.getMessageSchemaConfig(field.Message)
		cfg.nested = &nestedCfg
	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{
			typeName:   kindTypeName,
			enumValues: sg.getEnumValues(field),
		}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
			isBytes:  true,
		}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.nested = &schemaFieldConfig{
			typeName: jsString,
			pattern:  "^-?[0-9]+$",
		}
	default:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
		}
	}

	sg.emitSchemaField(cfg)
	return nil
}

func (sg *MessageSchemaGenerator) emitMapSchema(field *protogen.Field, title, description string) error {
	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsObject,
	}

	mapValue := field.Desc.MapValue()
	mapKey := field.Desc.MapKey()

	// 1. Map Keys (JSON keys are always strings, check for numeric types)
	switch mapKey.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.propertyNamesPattern = "^-?[0-9]+$"
	case protoreflect.BoolKind:
		cfg.propertyNamesPattern = "^(true|false)$"
	}

	kindTypeName, err := sg.getKindTypeName(mapValue)
	if err != nil {
		return err
	}

	// 2. Map Values
	switch mapValue.Kind() {
	case protoreflect.MessageKind:
		// Find the actual message type of the map value
		var valMsg *protogen.Message
		for _, f := range field.Message.Fields {
			if f.Desc.Number() == 2 {
				valMsg = f.Message
				break
			}
		}
		if valMsg == nil {
			return fmt.Errorf("map value message not found for %s", field.Desc.FullName())
		}
		nestedCfg := sg.getMessageSchemaConfig(valMsg)
		cfg.nested = &nestedCfg

	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{
			typeName:   kindTypeName,
			enumValues: sg.getEnumValuesFromDescriptor(mapValue.Enum()),
		}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
			isBytes:  true,
		}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.nested = &schemaFieldConfig{
			typeName: jsString,
			pattern:  "^-?[0-9]+$",
		}
	default:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
		}
	}

	sg.emitSchemaField(cfg)
	return nil
}

func (sg *MessageSchemaGenerator) getMessageSchemaConfig(msg *protogen.Message) schemaFieldConfig {
	fullName := string(msg.Desc.FullName())
	switch fullName {
	case "google.protobuf.Timestamp":
		return schemaFieldConfig{typeName: jsString, format: "date-time", description: "RFC 3339 timestamp"}
	case "google.protobuf.Duration":
		return schemaFieldConfig{typeName: jsString, pattern: `^([0-9]+\.?[0-9]*|\.[0-9]+)s$`, description: "Duration string (e.g. '1.5s')"}
	case "google.protobuf.Struct":
		return schemaFieldConfig{typeName: jsObject, description: "Arbitrary JSON object"}
	case "google.protobuf.Value":
		return schemaFieldConfig{description: "Any JSON value"}
	case "google.protobuf.ListValue":
		return schemaFieldConfig{
			typeName:    jsArray,
			description: "Repeated JSON values",
		}
	case "google.protobuf.Any":
		return schemaFieldConfig{typeName: jsObject, description: "Any protobuf message (must include @type)"}
	case "google.protobuf.FieldMask":
		return schemaFieldConfig{typeName: jsString, description: "Field mask paths (comma separated)"}
	case "google.protobuf.Empty":
		return schemaFieldConfig{typeName: jsObject, description: "Empty object"}
	case "google.protobuf.BoolValue":
		return schemaFieldConfig{typeName: jsBoolean}
	case "google.protobuf.StringValue":
		return schemaFieldConfig{typeName: jsString}
	case "google.protobuf.Int32Value", "google.protobuf.UInt32Value":
		return schemaFieldConfig{typeName: jsInteger}
	case "google.protobuf.Int64Value", "google.protobuf.UInt64Value":
		return schemaFieldConfig{typeName: jsString, pattern: "^-?[0-9]+$"}
	}
	return schemaFieldConfig{messageRef: sg.referenceName(msg)}
}

func (sg *MessageSchemaGenerator) emitScalarSchema(field *protogen.Field, title, description string) error {
	kindTypeName, err := sg.getKindTypeName(field.Desc)
	if err != nil {
		return err
	}

	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    kindTypeName,
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		// Handle WKTs or get reference
		nestedCfg := sg.getMessageSchemaConfig(field.Message)
		// Merge WKT config onto main config
		cfg.typeName = nestedCfg.typeName
		cfg.format = nestedCfg.format
		cfg.pattern = nestedCfg.pattern
		cfg.messageRef = nestedCfg.messageRef
		cfg.nested = nestedCfg.nested

		// Prefer the WKT description if the field doc is empty, otherwise prefer field doc
		if cfg.description == "" && nestedCfg.description != "" {
			cfg.description = nestedCfg.description
		}
	case protoreflect.EnumKind:
		cfg.enumValues = sg.getEnumValues(field)
	case protoreflect.BytesKind:
		cfg.isBytes = true
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.pattern = "^-?[0-9]+$"
	}

	sg.emitSchemaField(cfg)
	return nil
}

func (gr *Generator) escapeGoString(s string) string {
	quoted := strconv.Quote(s)
	return quoted[1 : len(quoted)-1]
}

func (gr *Generator) getTitleAndDescription(desc protoreflect.Descriptor) (title string, description string) {
	src := desc.ParentFile().SourceLocations().ByDescriptor(desc)
	if src.LeadingComments != "" {
		comments := strings.TrimSpace(src.LeadingComments)
		parts := strings.SplitN(comments, "\n\n", 2)
		if len(parts) < 2 {
			parts = strings.SplitN(comments, "\r\n\r\n", 2)
		}
		if len(parts) == 2 {
			title = strings.TrimSpace(parts[0])
			description = strings.TrimSpace(parts[1])
		} else {
			description = comments
		}
	}
	return title, description
}

func (sg *MessageSchemaGenerator) generateMessageJSONSchema(message *protogen.Message) error {
	messageName := string(message.Desc.FullName())
	if sg.visited[messageName] {
		return nil
	}
	sg.visited[messageName] = true

	// 1. Calculate Required Fields
	// In Proto3, fields are required by default unless marked 'optional' or part of a 'oneof'.
	var requiredFields []string
	for _, field := range message.Fields {
		// Skip fields that are part of a OneOf (handled by schema.OneOf logic)
		if field.Oneof != nil && !field.Oneof.Desc.IsSynthetic() {
			continue
		}

		// Skip fields explicitly marked as optional
		if field.Desc.HasOptionalKeyword() {
			continue
		}

		// Use JSONName (camelCase)
		requiredFields = append(requiredFields, field.Desc.JSONName())
	}

	title, description := sg.gr.getTitleAndDescription(message.Desc)

	sg.gen.P(fmt.Sprintf("// %s_JsonSchema is the JSON schema for the %s message", message.GoIdent.GoName, message.Desc.Name()))
	sg.gen.P(fmt.Sprintf("func %s_JsonSchema() *jsonschema.Schema {", message.GoIdent.GoName))
	sg.gen.P("// Initialize the schema")
	sg.gen.P("schema := &jsonschema.Schema{")
	sg.gen.P(`Type: "object",`)
	if title != "" {
		sg.gen.P(fmt.Sprintf(`Title: "%s",`, sg.gr.escapeGoString(title)))
	}
	if description != "" {
		sg.gen.P(fmt.Sprintf(`Description: "%s",`, sg.gr.escapeGoString(description)))
	}
	sg.gen.P(`Properties: make(map[string]*jsonschema.Schema),`)
	// 2. Emit Required Fields
	if len(requiredFields) > 0 {
		sg.gen.P(`Required: []string{`)
		for _, reqField := range requiredFields {
			sg.gen.P(fmt.Sprintf(`"%s",`, reqField))
		}
		sg.gen.P(`},`)
	} else {
		sg.gen.P(`Required: []string{},`)
	}
	sg.gen.P("}")
	sg.gen.P()

	oneofGroups := make(map[string][]string)

	for _, field := range message.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
			groupName := string(oneof.Desc.Name())
			oneofGroups[groupName] = append(oneofGroups[groupName], field.Desc.JSONName())
		}
		if err := sg.generateFieldJSONSchema(field); err != nil {
			return err
		}
		sg.gen.P("")
	}

	if len(oneofGroups) > 0 {
		var groupNames []string
		for name := range oneofGroups {
			groupNames = append(groupNames, name)
		}
		sort.Strings(groupNames)

		if len(groupNames) == 1 {
			fields := oneofGroups[groupNames[0]]
			sg.gen.P(`schema.OneOf = []*jsonschema.Schema{`)
			for _, f := range fields {
				sg.gen.P(fmt.Sprintf(`{Required: []string{"%s"}},`, f))
			}
			sg.gen.P(`}`)
		} else {
			sg.gen.P(`schema.AllOf = []*jsonschema.Schema{`)
			for _, name := range groupNames {
				fields := oneofGroups[name]
				sg.gen.P(`{`)
				sg.gen.P(`OneOf: []*jsonschema.Schema{`)
				for _, f := range fields {
					sg.gen.P(fmt.Sprintf(`{Required: []string{"%s"}},`, f))
				}
				sg.gen.P(`},`)
				sg.gen.P(`},`)
			}
			sg.gen.P(`}`)
		}
	}

	sg.gen.P("return schema")
	sg.gen.P("}")
	return nil
}

func (sg *MessageSchemaGenerator) generateFieldJSONSchema(field *protogen.Field) error {
	title, description := sg.gr.getTitleAndDescription(field.Desc)
	sg.gen.P("// Add the field to the schema")

	if field.Desc.IsList() {
		return sg.emitArraySchema(field, title, description)
	}
	if field.Desc.IsMap() {
		return sg.emitMapSchema(field, title, description)
	}
	return sg.emitScalarSchema(field, title, description)
}

func (sg *MessageSchemaGenerator) getKindTypeName(desc protoreflect.FieldDescriptor) (string, error) {
	switch desc.Kind() {
	case protoreflect.BoolKind:
		return jsBoolean, nil
	case protoreflect.EnumKind:
		return jsString, nil
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind:
		return jsInteger, nil
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		return jsString, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return jsNumber, nil
	case protoreflect.StringKind:
		return jsString, nil
	case protoreflect.BytesKind:
		return jsString, nil
	case protoreflect.MessageKind:
		return jsObject, nil
	case protoreflect.GroupKind:
		return jsObject, nil
	default:
		return "", fmt.Errorf("unsupported type: %s", desc.Kind())
	}
}

func (sg *MessageSchemaGenerator) referenceName(msg *protogen.Message) string {
	return sg.gen.QualifiedGoIdent(msg.GoIdent) + "_JsonSchema()"
}

// getEnumValues extracts enum value names.
// Note: We use the Proto Value Name directly (Desc.Name()) because protojson defaults to
// using the string name of the enum, not the Go constant name.
func (sg *MessageSchemaGenerator) getEnumValues(field *protogen.Field) []string {
	var enumValues []string
	for _, value := range field.Enum.Values {
		enumValues = append(enumValues, string(value.Desc.Name()))
	}
	return enumValues
}

func (sg *MessageSchemaGenerator) getEnumValuesFromDescriptor(enumDesc protoreflect.EnumDescriptor) []string {
	var enumValues []string
	values := enumDesc.Values()
	for i := 0; i < values.Len(); i++ {
		enumValues = append(enumValues, string(values.Get(i).Name()))
	}
	return enumValues
}
