package plugin

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// An enumeration of the JSON Schema type names.
const (
	jsArray   = "array"
	jsBoolean = "boolean"
	jsInteger = "integer"
	jsNull    = "null"
	jsNumber  = "number"
	jsObject  = "object"
	jsString  = "string"

	defsPrefix = "#/$defs/"

	// Any integers greater or less than these extrema cannot be safely represented
	// according to RFC8259.
	jsMaxInt  = 1<<53 - 1
	jsMinInt  = -jsMaxInt
	jsMaxUint = uint64(jsMaxInt)
)

type Generator struct{}

func (gr *Generator) generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + "_jsonschema.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-jsonschema. DO NOT EDIT.")
	g.P("// ")
	g.P(fmt.Sprintf("// Source: %s", file.Desc.Path()))
	g.P("// ")
	g.P(fmt.Sprintf("// Generated on: %s UTC", time.Now().UTC().Format("2006-01-02 15:04:05")))

	g.P()

	// Add package name
	g.P(fmt.Sprintf("package %s", file.GoPackageName))

	// Only add imports if there are messages in the file
	if len(file.Messages) > 0 {
		// Add imports
		g.P("import (")
		g.P("\"github.com/google/jsonschema-go/jsonschema\"")
		g.P(")")
		g.P()
	}

	// Get all messages
	messages := gr.getMessages(file.Messages, make(map[string]bool))

	// Generate JSON schemas for messages

	for _, msg := range messages {
		sg := &MessageSchemaGenerator{
			gr:      gr,
			gen:     g,
			visited: make(map[string]bool),
		}
		if err := sg.generateMessageJSONSchema(msg); err != nil {
			return nil, err
		}
		g.P()
	}

	return g, nil
}

func (gr *Generator) getMessages(messages []*protogen.Message, visited map[string]bool) []*protogen.Message {
	var results []*protogen.Message

	for _, message := range messages {
		// Get the fully qualified name of the message
		messageName := string(message.Desc.FullName())

		// Check if we've already processed this message type
		if visited[messageName] {
			continue
		}

		// Mark the message as visited
		visited[messageName] = true

		for _, field := range message.Fields {
			if field.Desc.Kind() == protoreflect.MessageKind {
				nestedMessages := gr.getMessages([]*protogen.Message{field.Message}, visited)
				results = append(results, nestedMessages...)
			}
		}

		results = append(results, message)
	}

	return results
}

type MessageSchemaGenerator struct {
	gr      *Generator
	gen     *protogen.GeneratedFile
	visited map[string]bool
}

// schemaFieldConfig holds configuration for generating a JSON schema field.
type schemaFieldConfig struct {
	fieldName            string   // JSON field name
	title                string   // Schema title
	description          string   // Schema description
	typeName             string   // JSON Schema type ("array", "object", "string", etc.)
	format               string   // JSON Schema format ("date-time", "email", etc.)
	propertyNamesPattern string   // Regex pattern for validating property names (map keys)
	enumValues           []string // Enum values (if any)
	isBytes              bool     // Whether this is a bytes field (adds ContentEncoding/Format)
	messageRef           string   // Message schema function reference (e.g., "Foo_JsonSchema()")
	// For nested schemas (Items for arrays, AdditionalProperties for maps)
	nested *schemaFieldConfig
}

// emitSchemaField generates Go code for a JSON schema property.
func (sg *MessageSchemaGenerator) emitSchemaField(cfg schemaFieldConfig) {
	// Handle message reference (direct assignment without inline schema)
	if cfg.messageRef != "" && cfg.typeName == "" && cfg.nested == nil {
		sg.gen.P(fmt.Sprintf(`schema.Properties["%s"] = %s`, cfg.fieldName, cfg.messageRef))
		return
	}

	sg.gen.P(fmt.Sprintf(`schema.Properties["%s"] = &jsonschema.Schema{`, cfg.fieldName))
	if cfg.typeName != "" {
		sg.gen.P(fmt.Sprintf(`Type: "%s",`, cfg.typeName))
	}
	if cfg.format != "" {
		sg.gen.P(fmt.Sprintf(`Format: "%s",`, cfg.format))
	}
	sg.gen.P(fmt.Sprintf(`Title: "%s",`, sg.gr.escapeGoString(cfg.title)))
	sg.gen.P(fmt.Sprintf(`Description: "%s",`, sg.gr.escapeGoString(cfg.description)))

	if cfg.propertyNamesPattern != "" {
		sg.gen.P(`PropertyNames: &jsonschema.Schema{`)
		sg.gen.P(fmt.Sprintf(`Pattern: "%s",`, cfg.propertyNamesPattern))
		sg.gen.P(`},`)
	}

	// Handle array items
	if cfg.typeName == jsArray && cfg.nested != nil {
		if cfg.nested.messageRef != "" {
			sg.gen.P(fmt.Sprintf(`Items: %s,`, cfg.nested.messageRef))
		} else {
			sg.gen.P(`Items: &jsonschema.Schema{`)
			sg.gen.P(fmt.Sprintf(`Type: "%s",`, cfg.nested.typeName))
			sg.emitEnumAndBytesFields(cfg.nested)
			sg.gen.P(`},`)
		}
	}

	// Handle map additionalProperties
	if cfg.typeName == jsObject && cfg.nested != nil {
		if cfg.nested.messageRef != "" {
			sg.gen.P(fmt.Sprintf(`AdditionalProperties: %s,`, cfg.nested.messageRef))
		} else {
			sg.gen.P(`AdditionalProperties: &jsonschema.Schema{`)
			sg.gen.P(fmt.Sprintf(`Type: "%s",`, cfg.nested.typeName))
			sg.emitEnumAndBytesFields(cfg.nested)
			sg.gen.P(`},`)
		}
	}

	// Handle scalar enum and bytes at root level
	if cfg.typeName != jsArray && cfg.typeName != jsObject {
		sg.emitEnumAndBytesFields(&cfg)
		sg.gen.P(`Required: []string{},`)
	}

	sg.gen.P("}")
}

// emitEnumAndBytesFields outputs enum values and/or bytes encoding fields.
func (sg *MessageSchemaGenerator) emitEnumAndBytesFields(cfg *schemaFieldConfig) {
	if len(cfg.enumValues) > 0 {
		sg.gen.P(`Enum: []any{`)
		for _, enumValue := range cfg.enumValues {
			sg.gen.P(fmt.Sprintf(`"%s",`, enumValue))
		}
		sg.gen.P(`},`)
	}
	if cfg.isBytes {
		sg.gen.P(`ContentEncoding: "base64",`)
		sg.gen.P(`Format: "byte",`)
	}
}

// emitArraySchema generates a JSON schema for a repeated (array) field.
func (sg *MessageSchemaGenerator) emitArraySchema(field *protogen.Field, title, description string) error {
	kindTypeName, err := sg.getKindTypeName(field.Desc)
	if err != nil {
		return err
	}

	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsArray,
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		nestedCfg := sg.getMessageSchemaConfig(field.Message)
		cfg.nested = &nestedCfg
	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{
			typeName:   kindTypeName,
			enumValues: sg.getEnumValues(field),
		}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
			isBytes:  true,
		}
	default:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
		}
	}

	sg.emitSchemaField(cfg)
	return nil
}

// emitMapSchema generates a JSON schema for a map field.
func (sg *MessageSchemaGenerator) emitMapSchema(field *protogen.Field, title, description string) error {
	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsObject,
	}

	// Maps in protobuf are represented as MessageKind with a special map entry type
	// We need to look at the map value type to determine the schema
	mapValue := field.Desc.MapValue()
	mapKey := field.Desc.MapKey()

	// Validate map keys (which are always strings in JSON)
	switch mapKey.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.propertyNamesPattern = "^-?[0-9]+$"
	case protoreflect.BoolKind:
		cfg.propertyNamesPattern = "^(true|false)$"
	}

	kindTypeName, err := sg.getKindTypeName(mapValue)
	if err != nil {
		return err
	}

	switch mapValue.Kind() {
	case protoreflect.MessageKind:
		var valMsg *protogen.Message
		for _, f := range field.Message.Fields {
			if f.Desc.Number() == 2 {
				valMsg = f.Message
				break
			}
		}
		if valMsg == nil {
			return fmt.Errorf("map value message not found for %s", field.Desc.FullName())
		}
		nestedCfg := sg.getMessageSchemaConfig(valMsg)
		cfg.nested = &nestedCfg
	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{
			typeName:   kindTypeName,
			enumValues: sg.getEnumValuesFromDescriptor(mapValue.Enum()),
		}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
			isBytes:  true,
		}
	default:
		cfg.nested = &schemaFieldConfig{
			typeName: kindTypeName,
		}
	}

	sg.emitSchemaField(cfg)
	return nil
}

// getMessageSchemaConfig returns the schema configuration for a message field,
// handling Well-Known Types (WKTs) or returning a reference.
func (sg *MessageSchemaGenerator) getMessageSchemaConfig(msg *protogen.Message) schemaFieldConfig {
	fullName := string(msg.Desc.FullName())
	switch fullName {
	case "google.protobuf.Timestamp":
		return schemaFieldConfig{typeName: jsString, format: "date-time", description: "RFC 3339 timestamp"}
	case "google.protobuf.Duration":
		return schemaFieldConfig{typeName: jsString, description: "Duration string (e.g. '1.5s')"}
	case "google.protobuf.Struct":
		return schemaFieldConfig{typeName: jsObject, description: "Arbitrary JSON object"}
	case "google.protobuf.Value":
		return schemaFieldConfig{description: "Any JSON value"}
	case "google.protobuf.Any":
		return schemaFieldConfig{typeName: jsObject, description: "Any protobuf message"}
	}
	return schemaFieldConfig{messageRef: sg.referenceName(msg)}
}

// emitScalarSchema generates a JSON schema for a scalar (non-array, non-map) field.
func (sg *MessageSchemaGenerator) emitScalarSchema(field *protogen.Field, title, description string) error {
	kindTypeName, err := sg.getKindTypeName(field.Desc)
	if err != nil {
		return err
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		// Handle WKTs or get reference
		cfg := sg.getMessageSchemaConfig(field.Message)
		// Merge with field info
		cfg.fieldName = field.Desc.JSONName()
		// Only overwrite title/desc if not provided by WKT (or always overwrite?)
		// Usually field doc is more relevant than type doc.
		cfg.title = title
		if description != "" {
			cfg.description = description
		}
		sg.emitSchemaField(cfg)
	case protoreflect.EnumKind:
		sg.emitSchemaField(schemaFieldConfig{
			fieldName:   field.Desc.JSONName(),
			title:       title,
			description: description,
			typeName:    kindTypeName,
			enumValues:  sg.getEnumValues(field),
		})
	case protoreflect.BytesKind:
		sg.emitSchemaField(schemaFieldConfig{
			fieldName:   field.Desc.JSONName(),
			title:       title,
			description: description,
			typeName:    kindTypeName,
			isBytes:     true,
		})
	default:
		sg.emitSchemaField(schemaFieldConfig{
			fieldName:   field.Desc.JSONName(),
			title:       title,
			description: description,
			typeName:    kindTypeName,
		})
	}

	return nil
}

// escapeGoString escapes a string for use in a Go string literal.
// It handles newlines, tabs, quotes, and backslashes.
func (gr *Generator) escapeGoString(s string) string {
	// Use strconv.Quote which properly escapes all special characters,
	// then remove the surrounding quotes since we're embedding it in our own string literal
	quoted := strconv.Quote(s)
	// Remove the surrounding quotes
	return quoted[1 : len(quoted)-1]
}

func (gr *Generator) getTitleAndDescription(desc protoreflect.Descriptor) (title string, description string) {
	src := desc.ParentFile().SourceLocations().ByDescriptor(desc)
	if src.LeadingComments != "" {
		comments := strings.TrimSpace(src.LeadingComments)
		// JSON schema has two fields for 'comments': title and description
		// To support this, split the comments into to sections.
		// Sections are separated by two newlines.
		// The first 'section' is the title, the rest are the description.
		parts := strings.SplitN(comments, "\n\n", 2)
		if len(parts) < 2 {
			// Check for Windows line endings.
			parts = strings.SplitN(comments, "\r\n\r\n", 2)
		}
		if len(parts) == 2 {
			// Found at least two sections.
			// The first section is the title.
			title = strings.TrimSpace(parts[0])
			// The rest are the description.
			description = strings.TrimSpace(parts[1])
		} else {
			// Only one section.
			// Use the whole comment as the description.
			description = comments
			// Leave the title as the default (empty for fields, the message name for messages).
		}
	}

	return title, description
}

// generateMessageJSONSchema generates a JSON schema for a message
func (sg *MessageSchemaGenerator) generateMessageJSONSchema(message *protogen.Message) error {
	// Get the fully qualified name of the message
	messageName := string(message.Desc.FullName())

	// Check if we've already processed this message type
	if sg.visited[messageName] {
		return nil
	}

	// Mark the message as visited
	sg.visited[messageName] = true

	title, description := sg.gr.getTitleAndDescription(message.Desc)

	sg.gen.P(fmt.Sprintf("// %s_JsonSchema is the JSON schema for the %s message", message.GoIdent.GoName, message.Desc.Name()))
	sg.gen.P(fmt.Sprintf("func %s_JsonSchema() *jsonschema.Schema {", message.GoIdent.GoName))
	sg.gen.P("// Initialize the schema")
	sg.gen.P("schema := &jsonschema.Schema{")
	sg.gen.P(`Type: "object",`)
	sg.gen.P(fmt.Sprintf(`Title: "%s",`, sg.gr.escapeGoString(title)))
	sg.gen.P(fmt.Sprintf(`Description: "%s",`, sg.gr.escapeGoString(description)))
	sg.gen.P(`Properties: make(map[string]*jsonschema.Schema),`)
	sg.gen.P(`Required: []string{},`)
	sg.gen.P("}")
	sg.gen.P()

	oneofGroups := make(map[string][]string)

	for _, field := range message.Fields {
		// Collect oneof info
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
			groupName := string(oneof.Desc.Name())
			oneofGroups[groupName] = append(oneofGroups[groupName], field.Desc.JSONName())
		}

		if err := sg.generateFieldJSONSchema(field); err != nil {
			return err
		}
		sg.gen.P("")
	}

	// Generate OneOf validation
	if len(oneofGroups) > 0 {
		// Sort keys for deterministic output
		var groupNames []string
		for name := range oneofGroups {
			groupNames = append(groupNames, name)
		}
		sort.Strings(groupNames)

		if len(groupNames) == 1 {
			// Single oneof group
			fields := oneofGroups[groupNames[0]]
			sg.gen.P(`schema.OneOf = []*jsonschema.Schema{`)
			for _, f := range fields {
				sg.gen.P(fmt.Sprintf(`{Required: []string{"%s"}},`, f))
			}
			sg.gen.P(`}`)
		} else {
			// Multiple oneof groups, use AllOf wrapping OneOfs
			sg.gen.P(`schema.AllOf = []*jsonschema.Schema{`)
			for _, name := range groupNames {
				fields := oneofGroups[name]
				sg.gen.P(`{`)
				sg.gen.P(`OneOf: []*jsonschema.Schema{`)
				for _, f := range fields {
					sg.gen.P(fmt.Sprintf(`{Required: []string{"%s"}},`, f))
				}
				sg.gen.P(`},`)
				sg.gen.P(`},`)
			}
			sg.gen.P(`}`)
		}
	}

	sg.gen.P("return schema")
	sg.gen.P("}")

	return nil
}

func (sg *MessageSchemaGenerator) generateFieldJSONSchema(field *protogen.Field) error {
	title, description := sg.gr.getTitleAndDescription(field.Desc)

	sg.gen.P("// Add the field to the schema")

	if field.Desc.IsList() {
		return sg.emitArraySchema(field, title, description)
	}

	if field.Desc.IsMap() {
		return sg.emitMapSchema(field, title, description)
	}

	return sg.emitScalarSchema(field, title, description)
}

func (sg *MessageSchemaGenerator) getKindTypeName(desc protoreflect.FieldDescriptor) (string, error) {
	switch desc.Kind() {
	case protoreflect.BoolKind:
		return jsBoolean, nil
	case protoreflect.EnumKind:
		return jsString, nil
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind:
		return jsInteger, nil
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		return jsString, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return jsNumber, nil
	case protoreflect.StringKind:
		return jsString, nil
	case protoreflect.BytesKind:
		return jsString, nil
	case protoreflect.MessageKind:
		return jsObject, nil
	case protoreflect.GroupKind:
		return jsObject, nil
	default:
		return "", fmt.Errorf("unsupported type: %s", desc.Kind())
	}
}

// referenceName returns the Go string representation of a reference to the schema function
// for the given message (e.g. "pkg.Message_JsonSchema()").
func (sg *MessageSchemaGenerator) referenceName(msg *protogen.Message) string {
	return sg.gen.QualifiedGoIdent(msg.GoIdent) + "_JsonSchema()"
}

// getEnumValues extracts enum value names from a protogen.Field.
// It strips the enum name prefix from each value's Go identifier.
func (sg *MessageSchemaGenerator) getEnumValues(field *protogen.Field) []string {
	var enumValues []string
	for _, value := range field.Enum.Values {
		name := field.Desc.Enum().Name()
		goName := value.GoIdent.GoName
		prefix := string(name) + "_"
		enumValue := strings.TrimPrefix(goName, prefix)
		enumValues = append(enumValues, enumValue)
	}
	return enumValues
}

// getEnumValuesFromDescriptor extracts enum value names from a protoreflect.EnumDescriptor.
// This is used for map value types where we only have the descriptor.
func (sg *MessageSchemaGenerator) getEnumValuesFromDescriptor(enumDesc protoreflect.EnumDescriptor) []string {
	var enumValues []string
	values := enumDesc.Values()
	for i := 0; i < values.Len(); i++ {
		value := values.Get(i)
		fullName := string(value.FullName())
		prefix := string(value.ParentFile().Package()) + "."
		enumValue := strings.TrimPrefix(fullName, prefix)
		enumValues = append(enumValues, enumValue)
	}
	return enumValues
}
