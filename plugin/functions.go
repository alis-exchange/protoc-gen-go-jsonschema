package plugin

import (
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	optionsPb "open.alis.services/protobuf/alis/open/options/v1"
)

// An enumeration of the JSON Schema type names.
const (
	jsArray   = "array"
	jsBoolean = "boolean"
	jsInteger = "integer"
	jsNull    = "null"
	jsNumber  = "number"
	jsObject  = "object"
	jsString  = "string"
)

type Generator struct{}

func (gr *Generator) generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	// Check File Options (generate_all)
	generateAll := false
	if opts := getFileJsonSchemaOptions(file); opts != nil {
		generateAll = opts.GetGenerate()
	}

	// Filter Messages based on options
	targetMessages := gr.getMessages(file.Messages, generateAll, make(map[string]bool))

	// Skip empty files
	if len(targetMessages) == 0 {
		return nil, nil
	}

	filename := file.GeneratedFilenamePrefix + "_jsonschema.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-jsonschema. DO NOT EDIT.")
	g.P("// ")
	g.P(fmt.Sprintf("// Source: %s", file.Desc.Path()))
	g.P("// ")
	g.P(fmt.Sprintf("// Generated on: %s UTC", time.Now().UTC().Format("2006-01-02 15:04:05")))

	g.P()
	g.P(fmt.Sprintf("package %s", file.GoPackageName))

	g.P("import (")
	g.P("\"github.com/google/jsonschema-go/jsonschema\"")
	g.P(")")
	g.P()

	for _, msg := range targetMessages {
		sg := &MessageSchemaGenerator{
			gr:      gr,
			gen:     g,
			visited: make(map[string]bool),
		}
		if err := sg.generateMessageJSONSchema(msg); err != nil {
			return nil, err
		}
		g.P()
	}

	return g, nil
}

func (gr *Generator) getMessages(messages []*protogen.Message, defaultGenerate bool, visited map[string]bool) []*protogen.Message {
	var results []*protogen.Message
	for _, message := range messages {
		// Skip Map Entries
		if message.Desc.IsMapEntry() {
			continue
		}

		// Skip WKTs (We handle them inline)
		if strings.HasPrefix(string(message.Desc.FullName()), "google.protobuf.") {
			continue
		}

		// Check Message Options (generate)
		shouldGen := defaultGenerate
		if opts := getMessageJsonSchemaOptions(message); opts != nil {
			shouldGen = opts.GetGenerate()
		}

		// If enabled, process this message and its dependencies
		if shouldGen {
			messageName := string(message.Desc.FullName())

			if !visited[messageName] {
				visited[messageName] = true
				results = append(results, message)

				// If we generate Parent, we MUST generate its Fields (Dependencies),
				// otherwise the schema will have broken $refs.
				// We pass 'true' to force them to generate.
				for _, field := range message.Fields {
					if field.Desc.Kind() == protoreflect.MessageKind {
						// Note: We force 'true' here because a dependency is required.
						depMessages := gr.getMessages([]*protogen.Message{field.Message}, true, visited)
						results = append(results, depMessages...)
					}
				}
			}
		}

		// We always traverse into nested messages (e.g. message Parent { message Child {} })
		// even if Parent is skipped, because Child might explicit opt-in.
		// We pass 'shouldGen' so the Child inherits the Parent's state.
		if len(message.Messages) > 0 {
			nestedResults := gr.getMessages(message.Messages, shouldGen, visited)
			results = append(results, nestedResults...)
		}
	}

	return results
}

type MessageSchemaGenerator struct {
	gr      *Generator
	gen     *protogen.GeneratedFile
	visited map[string]bool
}

// schemaFieldConfig holds configuration for generating a JSON schema field.
type schemaFieldConfig struct {
	fieldName            string
	title                string
	description          string
	typeName             string
	format               string
	pattern              string
	propertyNamesPattern string
	enumValues           []string
	isBytes              bool
	messageRef           string
	nested               *schemaFieldConfig
}

// emitSchemaField generates the Go code for a specific field using the config and applying Options overrides.
func (sg *MessageSchemaGenerator) emitSchemaField(cfg schemaFieldConfig, field *protogen.Field) {
	opts := getFieldJsonSchemaOptions(field)
	jsonNumberType := protogen.GoIdent{GoImportPath: "encoding/json", GoName: "Number"}

	// Optimization for direct references
	if cfg.messageRef != "" && cfg.typeName == "" && cfg.nested == nil {
		if opts == nil {
			sg.gen.P(fmt.Sprintf(`	schema.Properties["%s"] = %s`, cfg.fieldName, cfg.messageRef))
			return
		}
	}

	sg.gen.P(fmt.Sprintf(`	schema.Properties["%s"] = &jsonschema.Schema{`, cfg.fieldName))

	if cfg.typeName != "" {
		sg.gen.P(fmt.Sprintf(`		Type: "%s",`, cfg.typeName))
	}

	// --- Metadata (Apply to Root) ---
	title := cfg.title
	if opts.GetTitle() != "" {
		title = opts.GetTitle()
	}
	sg.gen.P(fmt.Sprintf(`		Title: "%s",`, sg.gr.escapeGoString(title)))

	desc := cfg.description
	if opts.GetDescription() != "" {
		desc = opts.GetDescription()
	}
	sg.gen.P(fmt.Sprintf(`		Description: "%s",`, sg.gr.escapeGoString(desc)))

	// --- Container Constraints (Apply to Root) ---
	if opts.GetMinItems() != 0 {
		val := opts.GetMinItems()
		sg.gen.P(fmt.Sprintf(`		MinItems: %d,`, val))
	}
	if opts.GetMaxItems() != 0 {
		val := opts.GetMaxItems()
		sg.gen.P(fmt.Sprintf(`		MaxItems: %d,`, val))
	}
	if opts.GetUniqueItems() {
		sg.gen.P(`		UniqueItems: true,`)
	}
	if opts.GetMinProperties() != 0 {
		val := opts.GetMinProperties()
		sg.gen.P(fmt.Sprintf(`		MinProperties: %d,`, val))
	}
	if opts.GetMaxProperties() != 0 {
		val := opts.GetMaxProperties()
		sg.gen.P(fmt.Sprintf(`		MaxProperties: %d,`, val))
	}

	// Helper to emit Value Constraints (Strings, Numbers, Enums, ContentEncoding)
	// We use this closure because these options apply to:
	// 1. The Root Schema (if it's a Scalar)
	// 2. The Nested Schema (if it's an Array/Map)
	emitValueConstraints := func(c schemaFieldConfig, indent string) {
		// Format
		format := c.format
		if opts.GetFormat() != "" {
			format = opts.GetFormat()
		}
		if format != "" {
			sg.gen.P(fmt.Sprintf(`%sFormat: "%s",`, indent, sg.gr.escapeGoString(format)))
		}

		// Pattern
		pattern := c.pattern
		if opts.GetPattern() != "" {
			pattern = opts.GetPattern()
		}
		if pattern != "" {
			sg.gen.P(fmt.Sprintf(`%sPattern: "%s",`, indent, sg.gr.escapeGoString(pattern)))
		}

		// ContentEncoding (Logic: Custom Option > Default base64 if bytes)
		if opts.GetContentEncoding() != "" {
			val := opts.GetContentEncoding()
			sg.gen.P(fmt.Sprintf(`%sContentEncoding: "%s",`, indent, sg.gr.escapeGoString(val)))
		} else if c.isBytes {
			sg.gen.P(fmt.Sprintf(`%sContentEncoding: "base64",`, indent))
		}

		// ContentMediaType
		if opts.GetContentMediaType() != "" {
			val := opts.GetContentMediaType()
			sg.gen.P(fmt.Sprintf(`%sContentMediaType: "%s",`, indent, sg.gr.escapeGoString(val)))
		}

		// Numeric
		if opts.GetMinimum() != 0 {
			val := opts.GetMinimum()
			// Use QualifiedGoIdent to ensure encoding/json is imported only if used
			sg.gen.P(fmt.Sprintf(`%sMinimum: %s("%g"),`, indent, sg.gen.QualifiedGoIdent(jsonNumberType), val))
		}
		if opts.GetMaximum() != 0 {
			val := opts.GetMaximum()
			sg.gen.P(fmt.Sprintf(`%sMaximum: %s("%g"),`, indent, sg.gen.QualifiedGoIdent(jsonNumberType), val))
		}
		if opts.GetExclusiveMinimum() {
			sg.gen.P(fmt.Sprintf(`%sExclusiveMinimum: true,`, indent))
		}
		if opts.GetExclusiveMaximum() {
			sg.gen.P(fmt.Sprintf(`%sExclusiveMaximum: true,`, indent))
		}

		// String Length
		if opts.GetMinLength() != 0 {
			val := opts.GetMinLength()
			sg.gen.P(fmt.Sprintf(`%sMinLength: %d,`, indent, val))
		}
		if opts.GetMaxLength() != 0 {
			val := opts.GetMaxLength()
			sg.gen.P(fmt.Sprintf(`%sMaxLength: %d,`, indent, val))
		}

		// Enums
		if len(c.enumValues) > 0 {
			sg.gen.P(fmt.Sprintf(`%sEnum: []any{`, indent))
			for _, enumValue := range c.enumValues {
				sg.gen.P(fmt.Sprintf(`%s	"%s",`, indent, enumValue))
			}
			sg.gen.P(fmt.Sprintf(`%s},`, indent))
		}
	}

	// --- Handle Nested Structures ---
	if cfg.nested != nil {
		targetField := "Items"
		if cfg.typeName == jsObject {
			targetField = "AdditionalProperties"
		}

		if cfg.nested.messageRef != "" {
			// Message Reference: Just emit the function call
			sg.gen.P(fmt.Sprintf(`		%s: %s,`, targetField, cfg.nested.messageRef))
		} else {
			// Inline Definition (Scalar list, WKT list, or external type)
			sg.gen.P(fmt.Sprintf(`		%s: &jsonschema.Schema{`, targetField))

			// If it's a basic type, print it
			if cfg.nested.typeName != "" {
				sg.gen.P(fmt.Sprintf(`			Type: "%s",`, cfg.nested.typeName))
			} else if cfg.nested.nested == nil {
				// Fallback for external types (e.g. google.type.LatLng) -> Object
				sg.gen.P(`			Type: "object",`)
			}

			// Apply Value Constraints to the NESTED item (e.g. pattern for string array items)
			emitValueConstraints(*cfg.nested, "			")

			sg.gen.P(`		},`)
		}
	} else {
		// --- Handle Scalar Values ---
		// Apply Value Constraints to the ROOT
		emitValueConstraints(cfg, "		")
	}

	// Map Property Names
	if cfg.propertyNamesPattern != "" {
		sg.gen.P(`		PropertyNames: &jsonschema.Schema{`)
		sg.gen.P(fmt.Sprintf(`			Pattern: "%s",`, sg.gr.escapeGoString(cfg.propertyNamesPattern)))
		sg.gen.P(`		},`)
	}

	sg.gen.P("	}")
}

// -----------------------------------------------------------------------------
// Helper Methods (Same as before, just included for completeness)
// -----------------------------------------------------------------------------

func (sg *MessageSchemaGenerator) getArraySchemaConfig(field *protogen.Field, title, description string) schemaFieldConfig {
	kindTypeName, _ := sg.getKindTypeName(field.Desc)
	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsArray,
	}
	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		nestedCfg := sg.getMessageSchemaConfig(field.Message)
		cfg.nested = &nestedCfg
	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName, enumValues: sg.getEnumValues(field)}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName, isBytes: true}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.nested = &schemaFieldConfig{typeName: jsString, pattern: "^-?[0-9]+$"}
	default:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName}
	}
	return cfg
}

func (sg *MessageSchemaGenerator) getMapSchemaConfig(field *protogen.Field, title, description string) schemaFieldConfig {
	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    jsObject,
	}
	mapValue := field.Desc.MapValue()
	mapKey := field.Desc.MapKey()

	switch mapKey.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
		protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.propertyNamesPattern = "^-?[0-9]+$"
	case protoreflect.BoolKind:
		cfg.propertyNamesPattern = "^(true|false)$"
	}

	kindTypeName, _ := sg.getKindTypeName(mapValue)
	switch mapValue.Kind() {
	case protoreflect.MessageKind:
		var valMsg *protogen.Message
		for _, f := range field.Message.Fields {
			if f.Desc.Number() == 2 {
				valMsg = f.Message
				break
			}
		}
		if valMsg != nil {
			nestedCfg := sg.getMessageSchemaConfig(valMsg)
			cfg.nested = &nestedCfg
		}
	case protoreflect.EnumKind:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName, enumValues: sg.getEnumValuesFromDescriptor(mapValue.Enum())}
	case protoreflect.BytesKind:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName, isBytes: true}
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.nested = &schemaFieldConfig{typeName: jsString, pattern: "^-?[0-9]+$"}
	default:
		cfg.nested = &schemaFieldConfig{typeName: kindTypeName}
	}
	return cfg
}

func (sg *MessageSchemaGenerator) getScalarSchemaConfig(field *protogen.Field, title, description string) schemaFieldConfig {
	kindTypeName, _ := sg.getKindTypeName(field.Desc)
	cfg := schemaFieldConfig{
		fieldName:   field.Desc.JSONName(),
		title:       title,
		description: description,
		typeName:    kindTypeName,
	}
	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		nestedCfg := sg.getMessageSchemaConfig(field.Message)
		cfg.typeName = nestedCfg.typeName
		cfg.format = nestedCfg.format
		cfg.pattern = nestedCfg.pattern
		cfg.messageRef = nestedCfg.messageRef
		cfg.nested = nestedCfg.nested
		if cfg.description == "" && nestedCfg.description != "" {
			cfg.description = nestedCfg.description
		}
	case protoreflect.EnumKind:
		cfg.enumValues = sg.getEnumValues(field)
	case protoreflect.BytesKind:
		cfg.isBytes = true
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		cfg.pattern = "^-?[0-9]+$"
	}
	return cfg
}

func (sg *MessageSchemaGenerator) getMessageSchemaConfig(msg *protogen.Message) schemaFieldConfig {
	fullName := string(msg.Desc.FullName())
	switch fullName {
	case "google.protobuf.Timestamp":
		return schemaFieldConfig{typeName: jsString, format: "date-time", description: "RFC 3339 timestamp"}
	case "google.protobuf.Duration":
		return schemaFieldConfig{typeName: jsString, pattern: `^([0-9]+\.?[0-9]*|\.[0-9]+)s$`, description: "Duration string (e.g. '1.5s')"}
	case "google.protobuf.Struct":
		return schemaFieldConfig{typeName: jsObject, description: "Arbitrary JSON object"}
	case "google.protobuf.Value":
		return schemaFieldConfig{description: "Any JSON value"}
	case "google.protobuf.ListValue":
		return schemaFieldConfig{typeName: jsArray, description: "Repeated JSON values"}
	case "google.protobuf.Any":
		return schemaFieldConfig{typeName: jsObject, description: "Any protobuf message (must include @type)"}
	case "google.protobuf.FieldMask":
		return schemaFieldConfig{typeName: jsString, description: "Field mask paths (comma separated)"}
	case "google.protobuf.Empty":
		return schemaFieldConfig{typeName: jsObject, description: "Empty object"}
	case "google.protobuf.BoolValue":
		return schemaFieldConfig{typeName: jsBoolean}
	case "google.protobuf.StringValue":
		return schemaFieldConfig{typeName: jsString}
	case "google.protobuf.Int32Value", "google.protobuf.UInt32Value":
		return schemaFieldConfig{typeName: jsInteger}
	case "google.protobuf.Int64Value", "google.protobuf.UInt64Value":
		return schemaFieldConfig{typeName: jsString, pattern: "^-?[0-9]+$"}
	}
	return schemaFieldConfig{messageRef: sg.referenceName(msg)}
}

func (sg *MessageSchemaGenerator) referenceName(msg *protogen.Message) string {
	pkg := string(msg.Desc.ParentFile().Package())
	if strings.HasPrefix(pkg, "google.") {
		return ""
	}
	funcName := msg.GoIdent.GoName + "_JsonSchema_WithDefs"
	ident := protogen.GoIdent{GoName: funcName, GoImportPath: msg.GoIdent.GoImportPath}
	return sg.gen.QualifiedGoIdent(ident) + "(defs)"
}

func (sg *MessageSchemaGenerator) generateMessageJSONSchema(message *protogen.Message) error {
	messageName := string(message.Desc.FullName())
	if sg.visited[messageName] {
		return nil
	}
	sg.visited[messageName] = true

	goName := message.GoIdent.GoName
	title, description := sg.gr.getTitleAndDescription(message.Desc)

	// Public Entry Point
	sg.gen.P(fmt.Sprintf("// %s_JsonSchema returns the JSON schema for the %s message.", goName, message.Desc.Name()))
	sg.gen.P(fmt.Sprintf("func (x *%s) JsonSchema() *jsonschema.Schema {", goName))
	sg.gen.P("    defs := make(map[string]*jsonschema.Schema)")
	sg.gen.P(fmt.Sprintf("    _ = %s_JsonSchema_WithDefs(defs)", goName))
	sg.gen.P(fmt.Sprintf("    root := defs[\"%s\"]", message.Desc.FullName()))
	sg.gen.P("    root.Definitions = defs")
	sg.gen.P("    return root")
	sg.gen.P("}")
	sg.gen.P()

	// Internal Helper
	sg.gen.P(fmt.Sprintf("func %s_JsonSchema_WithDefs(defs map[string]*jsonschema.Schema) *jsonschema.Schema {", goName))
	defKey := string(message.Desc.FullName())
	sg.gen.P(fmt.Sprintf("    if _, ok := defs[\"%s\"]; ok {", defKey))
	sg.gen.P(fmt.Sprintf("        return &jsonschema.Schema{Ref: \"#/$defs/%s\"}", defKey))
	sg.gen.P("    }")
	sg.gen.P()

	sg.gen.P("    schema := &jsonschema.Schema{")
	sg.gen.P(`        Type: "object",`)
	if title != "" {
		sg.gen.P(fmt.Sprintf(`        Title: "%s",`, sg.gr.escapeGoString(title)))
	}
	if description != "" {
		sg.gen.P(fmt.Sprintf(`        Description: "%s",`, sg.gr.escapeGoString(description)))
	}
	sg.gen.P(`        Properties: make(map[string]*jsonschema.Schema),`)

	var requiredFields []string
	for _, field := range message.Fields {
		opts := getFieldJsonSchemaOptions(field)
		if opts.GetIgnore() {
			continue
		}

		if field.Oneof == nil && !field.Desc.HasOptionalKeyword() {
			requiredFields = append(requiredFields, field.Desc.JSONName())
		}
	}

	if len(requiredFields) > 0 {
		sg.gen.P(`        Required: []string{`)
		for _, f := range requiredFields {
			sg.gen.P(fmt.Sprintf(`"%s",`, f))
		}
		sg.gen.P(`        },`)
	}
	sg.gen.P("    }")
	sg.gen.P()
	sg.gen.P(fmt.Sprintf("    defs[\"%s\"] = schema", defKey))
	sg.gen.P()

	oneofGroups := make(map[string][]string)
	for _, field := range message.Fields {
		opts := getFieldJsonSchemaOptions(field)
		if opts.GetIgnore() {
			continue
		}
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
			groupName := string(oneof.Desc.Name())
			oneofGroups[groupName] = append(oneofGroups[groupName], field.Desc.JSONName())
		}
		if err := sg.generateFieldJSONSchema(field); err != nil {
			return err
		}
		sg.gen.P("")
	}

	if len(oneofGroups) > 0 {
		var groupNames []string
		for name := range oneofGroups {
			groupNames = append(groupNames, name)
		}
		sort.Strings(groupNames)
		if len(groupNames) == 1 {
			fields := oneofGroups[groupNames[0]]
			sg.gen.P(`    schema.OneOf = []*jsonschema.Schema{`)
			for _, f := range fields {
				sg.gen.P(fmt.Sprintf(`        {Required: []string{"%s"}},`, f))
			}
			sg.gen.P(`    }`)
		} else {
			sg.gen.P(`    schema.AllOf = []*jsonschema.Schema{`)
			for _, name := range groupNames {
				fields := oneofGroups[name]
				sg.gen.P(`        {`)
				sg.gen.P(`            OneOf: []*jsonschema.Schema{`)
				for _, f := range fields {
					sg.gen.P(fmt.Sprintf(`                {Required: []string{"%s"}},`, f))
				}
				sg.gen.P(`            },`)
				sg.gen.P(`        },`)
			}
			sg.gen.P(`    }`)
		}
	}

	sg.gen.P(fmt.Sprintf("    return &jsonschema.Schema{Ref: \"#/$defs/%s\"}", defKey))
	sg.gen.P("}")
	return nil
}

func (sg *MessageSchemaGenerator) generateFieldJSONSchema(field *protogen.Field) error {
	title, description := sg.gr.getTitleAndDescription(field.Desc)
	var cfg schemaFieldConfig
	if field.Desc.IsList() {
		cfg = sg.getArraySchemaConfig(field, title, description)
	} else if field.Desc.IsMap() {
		cfg = sg.getMapSchemaConfig(field, title, description)
	} else {
		cfg = sg.getScalarSchemaConfig(field, title, description)
	}
	sg.emitSchemaField(cfg, field)
	return nil
}

func (sg *MessageSchemaGenerator) getKindTypeName(desc protoreflect.FieldDescriptor) (string, error) {
	switch desc.Kind() {
	case protoreflect.BoolKind:
		return jsBoolean, nil
	case protoreflect.EnumKind:
		return jsString, nil
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind:
		return jsInteger, nil
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind:
		return jsString, nil
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return jsNumber, nil
	case protoreflect.StringKind:
		return jsString, nil
	case protoreflect.BytesKind:
		return jsString, nil
	case protoreflect.MessageKind:
		return jsObject, nil
	case protoreflect.GroupKind:
		return jsObject, nil
	default:
		return "", fmt.Errorf("unsupported type: %s", desc.Kind())
	}
}

func (gr *Generator) escapeGoString(s string) string {
	quoted := strconv.Quote(s)
	return quoted[1 : len(quoted)-1]
}

func (gr *Generator) getTitleAndDescription(desc protoreflect.Descriptor) (title string, description string) {
	src := desc.ParentFile().SourceLocations().ByDescriptor(desc)
	if src.LeadingComments != "" {
		comments := strings.TrimSpace(src.LeadingComments)
		parts := strings.SplitN(comments, "\n\n", 2)
		if len(parts) < 2 {
			parts = strings.SplitN(comments, "\r\n\r\n", 2)
		}
		if len(parts) == 2 {
			title = strings.TrimSpace(parts[0])
			description = strings.TrimSpace(parts[1])
		} else {
			description = comments
		}
	}
	return title, description
}

func (sg *MessageSchemaGenerator) getEnumValues(field *protogen.Field) []string {
	var enumValues []string
	for _, value := range field.Enum.Values {
		enumValues = append(enumValues, string(value.Desc.Name()))
	}
	return enumValues
}

func (sg *MessageSchemaGenerator) getEnumValuesFromDescriptor(enumDesc protoreflect.EnumDescriptor) []string {
	var enumValues []string
	values := enumDesc.Values()
	for i := 0; i < values.Len(); i++ {
		enumValues = append(enumValues, string(values.Get(i).Name()))
	}
	return enumValues
}

// Helper for file options JsonSchema
func getFileJsonSchemaOptions(file *protogen.File) *optionsPb.FileOptions_JsonSchema {
	opts := file.Desc.Options()
	if !proto.HasExtension(opts, optionsPb.E_File) {
		return nil
	}
	fileOpts := proto.GetExtension(opts, optionsPb.E_File).(*optionsPb.FileOptions)
	return fileOpts.GetJsonSchema()
}

// Helper for message options JsonSchema
func getMessageJsonSchemaOptions(message *protogen.Message) *optionsPb.MessageOptions_JsonSchema {
	opts := message.Desc.Options()
	if !proto.HasExtension(opts, optionsPb.E_Message) {
		return nil
	}
	msgOpts := proto.GetExtension(opts, optionsPb.E_Message).(*optionsPb.MessageOptions)
	return msgOpts.GetJsonSchema()
}

// Helper for field options JsonSchema
func getFieldJsonSchemaOptions(field *protogen.Field) *optionsPb.FieldOptions_JsonSchema {
	opts := field.Desc.Options()
	if !proto.HasExtension(opts, optionsPb.E_Field) {
		return nil
	}
	fieldOpts := proto.GetExtension(opts, optionsPb.E_Field).(*optionsPb.FieldOptions)
	return fieldOpts.GetJsonSchema()
}
